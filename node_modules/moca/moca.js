import path from "path";

var 
  num = 0,
  corrects = 0,
  errors = 0,
  begin = false,
  errorList = [];

function printCorrect(s) {
  console.log("\x1b[32m" + s + "\x1b[0m");
}

function printError(s) {
  console.log("\x1b[31m" + s + "\x1b[0m");
}

function printTitle(s) {
  console.log("\x1b[1m" + s + "\x1b[0m");
}

class MonoError {
  constructor(num, name, msg, traceback) {
    this.num = num
    this.name = name
    this.msg = msg
    this.traceback = traceback
  }
}

export async function test(name, msg, promise) {
  if (!begin) {
    printTitle("\nTest " + process.argv[1] + "\n");
    begin = true;  
  }
  printTitle("  " + (num) + ") " + name);
  try {
    var start = new Date().getTime();
    await promise();
    var end = new Date().getTime();
    printCorrect("     ✓ " + msg + " (" + (end - start) + " ms)");
    corrects += 1;
  } catch (e) { 
    var end = new Date().getTime(); 
    if (e === undefined) {
      e = new Error("invalid error object");
    }
    printError("     × " + (e.message) + " (" + (end - start) + " ms)");
    errors += 1
    errorList.push(new MonoError(num, name, msg, e.stack))
  }
  console.log("");
  num += 1;
}

export function testComplete() {
  printCorrect("  " + (corrects) + " passing");
  printError("  " + (errors) + " failing");
  console.log("");
  for (var error of errorList) {
    printTitle("  " + (error.num) + ") " + error.name + " " + error.msg + ":");
    var tbs = error.traceback.split("\n");
    for (var line of tbs) {
      printError("     " + line);
    }
  }
  process.exit(0);
}