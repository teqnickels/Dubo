"use strict";

require("babel-polyfill");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.test = undefined;

var test = exports.test = function () {
  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(name, msg, promise) {
    var start, end;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!begin) {
              printTitle("\nTest " + process.argv[1] + "\n");
              begin = true;
            }
            printTitle("  " + num + ") " + name);
            _context.prev = 2;
            start = new Date().getTime();
            _context.next = 6;
            return promise();

          case 6:
            end = new Date().getTime();

            printCorrect("     ✓ " + msg + " (" + (end - start) + " ms)");
            corrects += 1;
            _context.next = 18;
            break;

          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](2);
            end = new Date().getTime();

            if (_context.t0 === undefined) {
              _context.t0 = new Error("invalid error object");
            }
            printError("     × " + _context.t0.message + " (" + (end - start) + " ms)");
            errors += 1;
            errorList.push(new MonoError(num, name, msg, _context.t0.stack));

          case 18:
            console.log("");
            num += 1;

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[2, 11]]);
  }));

  return function test(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

exports.testComplete = testComplete;

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var num = 0,
    corrects = 0,
    errors = 0,
    begin = false,
    errorList = [];

function printCorrect(s) {
  console.log("\x1b[32m" + s + "\x1b[0m");
}

function printError(s) {
  console.log("\x1b[31m" + s + "\x1b[0m");
}

function printTitle(s) {
  console.log("\x1b[1m" + s + "\x1b[0m");
}

var MonoError = function MonoError(num, name, msg, traceback) {
  _classCallCheck(this, MonoError);

  this.num = num;
  this.name = name;
  this.msg = msg;
  this.traceback = traceback;
};

function testComplete() {
  printCorrect("  " + corrects + " passing");
  printError("  " + errors + " failing");
  console.log("");
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = errorList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var error = _step.value;

      printTitle("  " + error.num + ") " + error.name + " " + error.msg + ":");
      var tbs = error.traceback.split("\n");
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = tbs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var line = _step2.value;

          printError("     " + line);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  process.exit(0);
}
